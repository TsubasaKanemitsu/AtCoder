## B
### 思考したこと
- 条件1について

X1,X2,X3,X4が同じというのをsetで変換して、ユニークな数が1になれば全て同じと捉えていた。
他の方法としてX1 == X2 == X3 == X4という条件で同じかどうか見ることができた。

- 条件2について
1 <= j <= 8についてはX_iとX_i+1を比較する際にX_i + 1 == X_i+1
という条件で確認できると思ったが、9の次が0になるという状態を上記のように簡潔に表現する方法がわからず、条件を複雑にして実装していた。

解説通り、9の次が0になるというのは10で周期を持つという意味なので
比較する際には「%10」で割った余りの値で比較することが重要である。

### 学び
数値に周期があるという特性を割り算の余りを用いて表現する。

## C
### 思考したこと
- 条件
    - 与えられた2つの数列であるA,Bから1つずつ要素を選んで2つの差の最小値を選ぶ。
    - N, Mの長さは最大で2✖️10^5なので、O(N^2)の全探索による比較は無理。
        - O(N)やO(NlogN)に高速化が可能か考える
    - A[i]、B[i]は1以上である。マイナスの値は取らない。
    - 2つの差の最小値を求めるだけなので、(i, j)の順序は考慮しなくていい。
        - ソートが可能。
    - 最小値を求めたいということは、A[i]とB[i]の値が近いもの同士で比較するのがいいということ。
        - ソートして、AとBそれぞれの値の小さい方から順に差分を確認していけばいい。
        - 差分が大きい = A[i]またはB[i]の値のどちらか一方の値が大きいということ。差分を縮めるためには、どちらかの値を大きくする必要がある。昇順にソートしていれば、配列を次に進める=値を大きくするということなので、線形探索で差分を確認していくことが可能になる。
        - 最初のソートと差分確認の線形探索を合わせてO(NlogN+MlogM)で解ける
- 実装方針
    - A,Bをソートする
    - A,Bの差分の算出に用いている配列の位置を管理する変数を用意する。（A:cur_a, B:cur_bとする）
    - 更新の際に気をつけるべき条件
        - cur_a < len(A)
        - cur_b < len(B)
        - A[cur_a] > B[cur_b]の時、cur_b = cur_b + 1
        - A[cur_a] < B[cur_b]の時、cur_a = cur_a + 1
    - 更新方法
        - res = min(res, diff)
### 解説メモ
順序が意味を持たない場合、ソートして単調性を持たせると問題を解きやすくなることがあるので、ソートせずに問題を解けるならソートしても解けると考え、ソートすることを考察に含めることで損することはない。

